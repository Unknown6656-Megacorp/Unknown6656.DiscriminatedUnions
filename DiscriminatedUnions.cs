#define UNSAFE

////////////////////////////////////////////////////// AUTOGENERATED //////////////////////////////////////////////////////
// WARNING: All code changes to this file will be lost upon regeneration.                                                //
// Autogenerated on 2022-03-13 09:20:35:465260                                                                           //
// Maybe (hopefully) this code file will be obsolete in C# 11                                                            //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

using System.Diagnostics.CodeAnalysis;
using System;

namespace Unknown6656;


#if UNSAFE
/// <summary>
/// An interface for discriminated type-unsafe unions.
/// </summary>
public interface IUnsafeUnion
{
    /// <summary>
    /// Returns the union value cast to the given generic type.
    /// <para/>
    /// It is advised to use the methods <see cref="AsValueType{T}"/> or <see cref="AsReferenceType{T}"/> instead.
    /// </summary>
    [return: MaybeNull]
    T As<T>();

    /// <summary>
    /// Returns the union value cast to the given generic value type.
    /// </summary>
    T AsValueType<T>() where T : struct;

    /// <summary>
    /// Returns the union value cast to the given generic reference type.
    /// </summary>
    T? AsReferenceType<T>() where T : class;

    /// <summary>
    /// Returns whether the union contains a value of the given generic type.
    /// </summary>
    bool Is<T>();

    /// <summary>
    /// Returns whether the union contains a value of the given generic type.
    /// </summary>
    bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value);

    /// <summary>
    /// The union's type-unsafe item.
    /// </summary>
    object? UnsafeItem { get; }
}
#endif

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 2 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 2 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
#endif
public abstract record Union<T0, T1>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1> union) => union.As<T1>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1>(T1 value) => new Case1(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 2 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 2 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 3 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 3 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
#endif
public abstract record Union<T0, T1, T2>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2> union) => union.As<T2>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2>(T2 value) => new Case2(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 3 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 3 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 3 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 4 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 4 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3> union) => union.As<T3>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3>(T3 value) => new Case3(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 4 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 4 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 4 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 4 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 5 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 5 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3, T4>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T4"/>.
    /// </summary>
    public virtual bool IsCase4 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T4"/>.
    /// </summary>
    [MaybeNull]
    public T4 AsCase4 => As<T4>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T4"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T4"/> (or <see langword="default"/>(<typeparamref name="T4"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T4"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T4 value)
    {
        (bool success, T4 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3, T4>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        T4 t4 => new Case4(t4),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3, T4>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3, T4> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3, T4> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3, T4> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3, T4> union) => union.As<T3>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase4"/>
    [return: MaybeNull]
    public static implicit operator T4(Union<T0, T1, T2, T3, T4> union) => union.As<T4>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4>(T3 value) => new Case3(value);

    /// <summary>
    /// Casts the given <typeparamref name="T4"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4>(T4 value) => new Case4(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3, T4>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 5 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3, T4>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 5 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3, T4>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 5 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3, T4>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 5 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }

    /// <summary>
    /// Union case №4 (Represents type <typeparamref name="T4"/>).
    /// </summary>
    public sealed record Case4
        : Union<T0, T1, T2, T3, T4>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase4 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T4 Item { get; }


        /// <summary>
        /// Creates a new union with 5 possible cases and sets it to a value of the type <typeparamref name="T4"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T4"/>.</param>
        public Case4(T4 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4) => func4(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4) => func4(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case4).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase4"/>
        public static implicit operator T4(Case4 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4}.AsCase4"/>
        public static explicit operator T4(Case4 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T4"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case4(T4 value) => new Case4(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 6 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 6 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3, T4, T5>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T4"/>.
    /// </summary>
    public virtual bool IsCase4 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T5"/>.
    /// </summary>
    public virtual bool IsCase5 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T4"/>.
    /// </summary>
    [MaybeNull]
    public T4 AsCase4 => As<T4>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T5"/>.
    /// </summary>
    [MaybeNull]
    public T5 AsCase5 => As<T5>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T4"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T4"/> (or <see langword="default"/>(<typeparamref name="T4"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T4"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T4 value)
    {
        (bool success, T4 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T5"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T5"/> (or <see langword="default"/>(<typeparamref name="T5"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T5"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T5 value)
    {
        (bool success, T5 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3, T4, T5>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        T4 t4 => new Case4(t4),
        T5 t5 => new Case5(t5),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3, T4, T5>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3, T4, T5> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3, T4, T5> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3, T4, T5> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3, T4, T5> union) => union.As<T3>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase4"/>
    [return: MaybeNull]
    public static implicit operator T4(Union<T0, T1, T2, T3, T4, T5> union) => union.As<T4>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase5"/>
    [return: MaybeNull]
    public static implicit operator T5(Union<T0, T1, T2, T3, T4, T5> union) => union.As<T5>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5>(T3 value) => new Case3(value);

    /// <summary>
    /// Casts the given <typeparamref name="T4"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5>(T4 value) => new Case4(value);

    /// <summary>
    /// Casts the given <typeparamref name="T5"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5>(T5 value) => new Case5(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3, T4, T5>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 6 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3, T4, T5>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 6 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3, T4, T5>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 6 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3, T4, T5>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 6 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }

    /// <summary>
    /// Union case №4 (Represents type <typeparamref name="T4"/>).
    /// </summary>
    public sealed record Case4
        : Union<T0, T1, T2, T3, T4, T5>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase4 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T4 Item { get; }


        /// <summary>
        /// Creates a new union with 6 possible cases and sets it to a value of the type <typeparamref name="T4"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T4"/>.</param>
        public Case4(T4 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5) => func4(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5) => func4(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case4).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase4"/>
        public static implicit operator T4(Case4 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase4"/>
        public static explicit operator T4(Case4 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T4"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case4(T4 value) => new Case4(value);
    }

    /// <summary>
    /// Union case №5 (Represents type <typeparamref name="T5"/>).
    /// </summary>
    public sealed record Case5
        : Union<T0, T1, T2, T3, T4, T5>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase5 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T5 Item { get; }


        /// <summary>
        /// Creates a new union with 6 possible cases and sets it to a value of the type <typeparamref name="T5"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T5"/>.</param>
        public Case5(T5 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5) => func5(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5) => func5(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case5).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase5"/>
        public static implicit operator T5(Case5 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5}.AsCase5"/>
        public static explicit operator T5(Case5 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T5"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case5(T5 value) => new Case5(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 7 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 7 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3, T4, T5, T6>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T4"/>.
    /// </summary>
    public virtual bool IsCase4 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T5"/>.
    /// </summary>
    public virtual bool IsCase5 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T6"/>.
    /// </summary>
    public virtual bool IsCase6 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T4"/>.
    /// </summary>
    [MaybeNull]
    public T4 AsCase4 => As<T4>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T5"/>.
    /// </summary>
    [MaybeNull]
    public T5 AsCase5 => As<T5>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T6"/>.
    /// </summary>
    [MaybeNull]
    public T6 AsCase6 => As<T6>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T4"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T4"/> (or <see langword="default"/>(<typeparamref name="T4"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T4"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T4 value)
    {
        (bool success, T4 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T5"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T5"/> (or <see langword="default"/>(<typeparamref name="T5"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T5"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T5 value)
    {
        (bool success, T5 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T6"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T6"/> (or <see langword="default"/>(<typeparamref name="T6"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T6"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T6 value)
    {
        (bool success, T6 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3, T4, T5, T6>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        T4 t4 => new Case4(t4),
        T5 t5 => new Case5(t5),
        T6 t6 => new Case6(t6),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3, T4, T5, T6>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T3>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase4"/>
    [return: MaybeNull]
    public static implicit operator T4(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T4>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase5"/>
    [return: MaybeNull]
    public static implicit operator T5(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T5>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase6"/>
    [return: MaybeNull]
    public static implicit operator T6(Union<T0, T1, T2, T3, T4, T5, T6> union) => union.As<T6>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T3 value) => new Case3(value);

    /// <summary>
    /// Casts the given <typeparamref name="T4"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T4 value) => new Case4(value);

    /// <summary>
    /// Casts the given <typeparamref name="T5"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T5 value) => new Case5(value);

    /// <summary>
    /// Casts the given <typeparamref name="T6"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6>(T6 value) => new Case6(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }

    /// <summary>
    /// Union case №4 (Represents type <typeparamref name="T4"/>).
    /// </summary>
    public sealed record Case4
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase4 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T4 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T4"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T4"/>.</param>
        public Case4(T4 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func4(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func4(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case4).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase4"/>
        public static implicit operator T4(Case4 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase4"/>
        public static explicit operator T4(Case4 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T4"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case4(T4 value) => new Case4(value);
    }

    /// <summary>
    /// Union case №5 (Represents type <typeparamref name="T5"/>).
    /// </summary>
    public sealed record Case5
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase5 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T5 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T5"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T5"/>.</param>
        public Case5(T5 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func5(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func5(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case5).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase5"/>
        public static implicit operator T5(Case5 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase5"/>
        public static explicit operator T5(Case5 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T5"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case5(T5 value) => new Case5(value);
    }

    /// <summary>
    /// Union case №6 (Represents type <typeparamref name="T6"/>).
    /// </summary>
    public sealed record Case6
        : Union<T0, T1, T2, T3, T4, T5, T6>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase6 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T6 Item { get; }


        /// <summary>
        /// Creates a new union with 7 possible cases and sets it to a value of the type <typeparamref name="T6"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T6"/>.</param>
        public Case6(T6 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6) => func6(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6) => func6(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case6).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase6"/>
        public static implicit operator T6(Case6 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6}.AsCase6"/>
        public static explicit operator T6(Case6 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T6"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case6(T6 value) => new Case6(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 8 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
/// <typeparam name="T7">The generic union case type 7.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 8 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
/// <typeparam name="T7">The generic union case type 7.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3, T4, T5, T6, T7>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <param name="func7">A function which matches the union type <typeparamref name="T7"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <param name="func7">A function which matches the union type <typeparamref name="T7"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T4"/>.
    /// </summary>
    public virtual bool IsCase4 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T5"/>.
    /// </summary>
    public virtual bool IsCase5 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T6"/>.
    /// </summary>
    public virtual bool IsCase6 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T7"/>.
    /// </summary>
    public virtual bool IsCase7 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T4"/>.
    /// </summary>
    [MaybeNull]
    public T4 AsCase4 => As<T4>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T5"/>.
    /// </summary>
    [MaybeNull]
    public T5 AsCase5 => As<T5>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T6"/>.
    /// </summary>
    [MaybeNull]
    public T6 AsCase6 => As<T6>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T7"/>.
    /// </summary>
    [MaybeNull]
    public T7 AsCase7 => As<T7>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T4"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T4"/> (or <see langword="default"/>(<typeparamref name="T4"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T4"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T4 value)
    {
        (bool success, T4 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T5"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T5"/> (or <see langword="default"/>(<typeparamref name="T5"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T5"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T5 value)
    {
        (bool success, T5 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T6"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T6"/> (or <see langword="default"/>(<typeparamref name="T6"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T6"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T6 value)
    {
        (bool success, T6 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T7"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T7"/> (or <see langword="default"/>(<typeparamref name="T7"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T7"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T7 value)
    {
        (bool success, T7 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3, T4, T5, T6, T7>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        T4 t4 => new Case4(t4),
        T5 t5 => new Case5(t5),
        T6 t6 => new Case6(t6),
        T7 t7 => new Case7(t7),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3, T4, T5, T6, T7>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T3>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase4"/>
    [return: MaybeNull]
    public static implicit operator T4(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T4>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase5"/>
    [return: MaybeNull]
    public static implicit operator T5(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T5>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase6"/>
    [return: MaybeNull]
    public static implicit operator T6(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T6>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase7"/>
    [return: MaybeNull]
    public static implicit operator T7(Union<T0, T1, T2, T3, T4, T5, T6, T7> union) => union.As<T7>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T3 value) => new Case3(value);

    /// <summary>
    /// Casts the given <typeparamref name="T4"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T4 value) => new Case4(value);

    /// <summary>
    /// Casts the given <typeparamref name="T5"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T5 value) => new Case5(value);

    /// <summary>
    /// Casts the given <typeparamref name="T6"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T6 value) => new Case6(value);

    /// <summary>
    /// Casts the given <typeparamref name="T7"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7>(T7 value) => new Case7(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }

    /// <summary>
    /// Union case №4 (Represents type <typeparamref name="T4"/>).
    /// </summary>
    public sealed record Case4
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase4 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T4 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T4"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T4"/>.</param>
        public Case4(T4 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func4(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func4(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case4).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase4"/>
        public static implicit operator T4(Case4 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase4"/>
        public static explicit operator T4(Case4 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T4"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case4(T4 value) => new Case4(value);
    }

    /// <summary>
    /// Union case №5 (Represents type <typeparamref name="T5"/>).
    /// </summary>
    public sealed record Case5
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase5 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T5 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T5"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T5"/>.</param>
        public Case5(T5 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func5(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func5(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case5).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase5"/>
        public static implicit operator T5(Case5 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase5"/>
        public static explicit operator T5(Case5 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T5"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case5(T5 value) => new Case5(value);
    }

    /// <summary>
    /// Union case №6 (Represents type <typeparamref name="T6"/>).
    /// </summary>
    public sealed record Case6
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase6 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T6 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T6"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T6"/>.</param>
        public Case6(T6 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func6(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func6(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case6).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase6"/>
        public static implicit operator T6(Case6 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase6"/>
        public static explicit operator T6(Case6 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T6"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case6(T6 value) => new Case6(value);
    }

    /// <summary>
    /// Union case №7 (Represents type <typeparamref name="T7"/>).
    /// </summary>
    public sealed record Case7
        : Union<T0, T1, T2, T3, T4, T5, T6, T7>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase7 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T7 Item { get; }


        /// <summary>
        /// Creates a new union with 8 possible cases and sets it to a value of the type <typeparamref name="T7"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T7"/>.</param>
        public Case7(T7 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7) => func7(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7) => func7(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case7).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase7"/>
        public static implicit operator T7(Case7 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7}.AsCase7"/>
        public static explicit operator T7(Case7 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T7"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case7(T7 value) => new Case7(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 9 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
/// <typeparam name="T7">The generic union case type 7.</typeparam>
/// <typeparam name="T8">The generic union case type 8.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 9 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
/// <typeparam name="T7">The generic union case type 7.</typeparam>
/// <typeparam name="T8">The generic union case type 8.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <param name="func7">A function which matches the union type <typeparamref name="T7"/>.</param>
    /// <param name="func8">A function which matches the union type <typeparamref name="T8"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <param name="func7">A function which matches the union type <typeparamref name="T7"/>.</param>
    /// <param name="func8">A function which matches the union type <typeparamref name="T8"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T4"/>.
    /// </summary>
    public virtual bool IsCase4 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T5"/>.
    /// </summary>
    public virtual bool IsCase5 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T6"/>.
    /// </summary>
    public virtual bool IsCase6 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T7"/>.
    /// </summary>
    public virtual bool IsCase7 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T8"/>.
    /// </summary>
    public virtual bool IsCase8 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T4"/>.
    /// </summary>
    [MaybeNull]
    public T4 AsCase4 => As<T4>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T5"/>.
    /// </summary>
    [MaybeNull]
    public T5 AsCase5 => As<T5>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T6"/>.
    /// </summary>
    [MaybeNull]
    public T6 AsCase6 => As<T6>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T7"/>.
    /// </summary>
    [MaybeNull]
    public T7 AsCase7 => As<T7>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T8"/>.
    /// </summary>
    [MaybeNull]
    public T8 AsCase8 => As<T8>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T4"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T4"/> (or <see langword="default"/>(<typeparamref name="T4"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T4"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T4 value)
    {
        (bool success, T4 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T5"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T5"/> (or <see langword="default"/>(<typeparamref name="T5"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T5"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T5 value)
    {
        (bool success, T5 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T6"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T6"/> (or <see langword="default"/>(<typeparamref name="T6"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T6"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T6 value)
    {
        (bool success, T6 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T7"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T7"/> (or <see langword="default"/>(<typeparamref name="T7"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T7"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T7 value)
    {
        (bool success, T7 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T8"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T8"/> (or <see langword="default"/>(<typeparamref name="T8"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T8"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T8 value)
    {
        (bool success, T8 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        T4 t4 => new Case4(t4),
        T5 t5 => new Case5(t5),
        T6 t6 => new Case6(t6),
        T7 t7 => new Case7(t7),
        T8 t8 => new Case8(t8),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T3>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase4"/>
    [return: MaybeNull]
    public static implicit operator T4(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T4>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase5"/>
    [return: MaybeNull]
    public static implicit operator T5(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T5>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase6"/>
    [return: MaybeNull]
    public static implicit operator T6(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T6>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase7"/>
    [return: MaybeNull]
    public static implicit operator T7(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T7>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase8"/>
    [return: MaybeNull]
    public static implicit operator T8(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8> union) => union.As<T8>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T3 value) => new Case3(value);

    /// <summary>
    /// Casts the given <typeparamref name="T4"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T4 value) => new Case4(value);

    /// <summary>
    /// Casts the given <typeparamref name="T5"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T5 value) => new Case5(value);

    /// <summary>
    /// Casts the given <typeparamref name="T6"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T6 value) => new Case6(value);

    /// <summary>
    /// Casts the given <typeparamref name="T7"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T7 value) => new Case7(value);

    /// <summary>
    /// Casts the given <typeparamref name="T8"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>(T8 value) => new Case8(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }

    /// <summary>
    /// Union case №4 (Represents type <typeparamref name="T4"/>).
    /// </summary>
    public sealed record Case4
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase4 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T4 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T4"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T4"/>.</param>
        public Case4(T4 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func4(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func4(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case4).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase4"/>
        public static implicit operator T4(Case4 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase4"/>
        public static explicit operator T4(Case4 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T4"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case4(T4 value) => new Case4(value);
    }

    /// <summary>
    /// Union case №5 (Represents type <typeparamref name="T5"/>).
    /// </summary>
    public sealed record Case5
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase5 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T5 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T5"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T5"/>.</param>
        public Case5(T5 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func5(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func5(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case5).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase5"/>
        public static implicit operator T5(Case5 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase5"/>
        public static explicit operator T5(Case5 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T5"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case5(T5 value) => new Case5(value);
    }

    /// <summary>
    /// Union case №6 (Represents type <typeparamref name="T6"/>).
    /// </summary>
    public sealed record Case6
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase6 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T6 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T6"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T6"/>.</param>
        public Case6(T6 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func6(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func6(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case6).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase6"/>
        public static implicit operator T6(Case6 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase6"/>
        public static explicit operator T6(Case6 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T6"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case6(T6 value) => new Case6(value);
    }

    /// <summary>
    /// Union case №7 (Represents type <typeparamref name="T7"/>).
    /// </summary>
    public sealed record Case7
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase7 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T7 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T7"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T7"/>.</param>
        public Case7(T7 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func7(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func7(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case7).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase7"/>
        public static implicit operator T7(Case7 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase7"/>
        public static explicit operator T7(Case7 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T7"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case7(T7 value) => new Case7(value);
    }

    /// <summary>
    /// Union case №8 (Represents type <typeparamref name="T8"/>).
    /// </summary>
    public sealed record Case8
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase8 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T8 Item { get; }


        /// <summary>
        /// Creates a new union with 9 possible cases and sets it to a value of the type <typeparamref name="T8"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T8"/>.</param>
        public Case8(T8 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8) => func8(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8) => func8(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case8).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase8"/>
        public static implicit operator T8(Case8 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8}.AsCase8"/>
        public static explicit operator T8(Case8 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T8"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case8(T8 value) => new Case8(value);
    }
}

#if UNSAFE
/// <summary>
/// A generic type-unsafe discriminated union with 10 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
/// <typeparam name="T7">The generic union case type 7.</typeparam>
/// <typeparam name="T8">The generic union case type 8.</typeparam>
/// <typeparam name="T9">The generic union case type 9.</typeparam>
#else
/// <summary>
/// A generic type-safe discriminated union with 10 different type cases.
/// </summary>
/// <typeparam name="T0">The generic union case type 0.</typeparam>
/// <typeparam name="T1">The generic union case type 1.</typeparam>
/// <typeparam name="T2">The generic union case type 2.</typeparam>
/// <typeparam name="T3">The generic union case type 3.</typeparam>
/// <typeparam name="T4">The generic union case type 4.</typeparam>
/// <typeparam name="T5">The generic union case type 5.</typeparam>
/// <typeparam name="T6">The generic union case type 6.</typeparam>
/// <typeparam name="T7">The generic union case type 7.</typeparam>
/// <typeparam name="T8">The generic union case type 8.</typeparam>
/// <typeparam name="T9">The generic union case type 9.</typeparam>
#endif
public abstract record Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
#if UNSAFE
    : IUnsafeUnion
#endif
{
    /// <summary>
    /// Matches the current union value with the given functions and executes the matching function.
    /// </summary>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <param name="func7">A function which matches the union type <typeparamref name="T7"/>.</param>
    /// <param name="func8">A function which matches the union type <typeparamref name="T8"/>.</param>
    /// <param name="func9">A function which matches the union type <typeparamref name="T9"/>.</param>
    public abstract void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9);

    /// <summary>
    /// Matches the current union value with the given functions and returns the common return value of the function.
    /// </summary>
    /// <typeparam name="T">Common return type</typeparam>
    /// <param name="func0">A function which matches the union type <typeparamref name="T0"/>.</param>
    /// <param name="func1">A function which matches the union type <typeparamref name="T1"/>.</param>
    /// <param name="func2">A function which matches the union type <typeparamref name="T2"/>.</param>
    /// <param name="func3">A function which matches the union type <typeparamref name="T3"/>.</param>
    /// <param name="func4">A function which matches the union type <typeparamref name="T4"/>.</param>
    /// <param name="func5">A function which matches the union type <typeparamref name="T5"/>.</param>
    /// <param name="func6">A function which matches the union type <typeparamref name="T6"/>.</param>
    /// <param name="func7">A function which matches the union type <typeparamref name="T7"/>.</param>
    /// <param name="func8">A function which matches the union type <typeparamref name="T8"/>.</param>
    /// <param name="func9">A function which matches the union type <typeparamref name="T9"/>.</param>
    /// <returns>Match result</returns>
    public abstract T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9);

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T0"/>.
    /// </summary>
    public virtual bool IsCase0 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T1"/>.
    /// </summary>
    public virtual bool IsCase1 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T2"/>.
    /// </summary>
    public virtual bool IsCase2 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T3"/>.
    /// </summary>
    public virtual bool IsCase3 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T4"/>.
    /// </summary>
    public virtual bool IsCase4 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T5"/>.
    /// </summary>
    public virtual bool IsCase5 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T6"/>.
    /// </summary>
    public virtual bool IsCase6 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T7"/>.
    /// </summary>
    public virtual bool IsCase7 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T8"/>.
    /// </summary>
    public virtual bool IsCase8 => false;

    /// <summary>
    /// Returns, whether the current union instance is from the type <typeparamref name="T9"/>.
    /// </summary>
    public virtual bool IsCase9 => false;
#if UNSAFE
    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T0"/>.
    /// </summary>
    [MaybeNull]
    public T0 AsCase0 => As<T0>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T1"/>.
    /// </summary>
    [MaybeNull]
    public T1 AsCase1 => As<T1>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T2"/>.
    /// </summary>
    [MaybeNull]
    public T2 AsCase2 => As<T2>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T3"/>.
    /// </summary>
    [MaybeNull]
    public T3 AsCase3 => As<T3>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T4"/>.
    /// </summary>
    [MaybeNull]
    public T4 AsCase4 => As<T4>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T5"/>.
    /// </summary>
    [MaybeNull]
    public T5 AsCase5 => As<T5>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T6"/>.
    /// </summary>
    [MaybeNull]
    public T6 AsCase6 => As<T6>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T7"/>.
    /// </summary>
    [MaybeNull]
    public T7 AsCase7 => As<T7>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T8"/>.
    /// </summary>
    [MaybeNull]
    public T8 AsCase8 => As<T8>();

    /// <summary>
    /// Returns the union value cast to the type <typeparamref name="T9"/>.
    /// </summary>
    [MaybeNull]
    public T9 AsCase9 => As<T9>();

    /// <inheritdoc/>
    public abstract object? UnsafeItem { get; }
#endif
    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T0"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T0"/> (or <see langword="default"/>(<typeparamref name="T0"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T0"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T0 value)
    {
        (bool success, T0 val) = Match(
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T1"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T1"/> (or <see langword="default"/>(<typeparamref name="T1"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T1"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T1 value)
    {
        (bool success, T1 val) = Match(
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T2"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T2"/> (or <see langword="default"/>(<typeparamref name="T2"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T2"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T2 value)
    {
        (bool success, T2 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T3"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T3"/> (or <see langword="default"/>(<typeparamref name="T3"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T3"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T3 value)
    {
        (bool success, T3 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T4"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T4"/> (or <see langword="default"/>(<typeparamref name="T4"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T4"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T4 value)
    {
        (bool success, T4 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T5"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T5"/> (or <see langword="default"/>(<typeparamref name="T5"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T5"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T5 value)
    {
        (bool success, T5 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T6"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T6"/> (or <see langword="default"/>(<typeparamref name="T6"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T6"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T6 value)
    {
        (bool success, T6 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T7"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T7"/> (or <see langword="default"/>(<typeparamref name="T7"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T7"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T7 value)
    {
        (bool success, T7 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!,
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T8"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T8"/> (or <see langword="default"/>(<typeparamref name="T8"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T8"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T8 value)
    {
        (bool success, T8 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c),
            _ => (false, default)!
        );

        value = val;

        return success;
    }

    /// <summary>
    /// Returns whether the union contains a value of the given generic type <typeparamref name="T9"/>.
    /// </summary>
    /// <param name="value">The union value cast to <typeparamref name="T9"/> (or <see langword="default"/>(<typeparamref name="T9"/>) if the return value is <see langword="false"/>).</param>
    /// <returns>Value indicating whether the union contains a value of the type <typeparamref name="T9"/>.</returns>
    public bool Is([MaybeNullWhen(false), NotNullWhen(true)] out T9 value)
    {
        (bool success, T9 val) = Match(
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            _ => (false, default)!,
            c => (true, c)
        );

        value = val;

        return success;
    }

#if UNSAFE
    /// <inheritdoc/>
    public bool Is<T>() => typeof(T) == UnsafeItem?.GetType();

    /// <inheritdoc/>
    public bool Is<T>([MaybeNullWhen(false), NotNullWhen(true)] out T value)
    {
        if (UnsafeItem is T v)
        {
            value = v;

            return true;
        }

        value = default;

        return false;
    }

    /// <inheritdoc/>
    [return: MaybeNull]
    public T As<T>() => UnsafeItem switch
    {
        T t => t,
        null => default,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    [return: MaybeNull]
    public T AsOrDefault<T>() => UnsafeItem switch
    {
        T t => t,
        _ => default
    };

    /// <inheritdoc/>
    public T AsValueType<T>() where T : struct => UnsafeItem switch
    {
        T t => t,
        _ => throw new InvalidCastException($"A discriminated union case of the type '{UnsafeItem?.GetType() ?? typeof(void)}' cannot be converted to a value of the type '{typeof(T)}'.")
    };

    /// <inheritdoc/>
    public T? AsReferenceType<T>() where T : class => As<T>();
#endif
    /// <inheritdoc/>
    public override string ToString() => UnsafeItem?.ToString() ?? string.Empty;

    // prevent inheritance by external classes
    private Union()
    {
    }

    public static Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>? FromObject(object? obj) => obj switch
    {
        T0 t0 => new Case0(t0),
        T1 t1 => new Case1(t1),
        T2 t2 => new Case2(t2),
        T3 t3 => new Case3(t3),
        T4 t4 => new Case4(t4),
        T5 t5 => new Case5(t5),
        T6 t6 => new Case6(t6),
        T7 t7 => new Case7(t7),
        T8 t8 => new Case8(t8),
        T9 t9 => new Case9(t9),
        null => null,
        _ => throw new ArgumentException($"An object of the type {obj.GetType()} cannot be cast to an union case of {typeof(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>)}.", nameof(obj))
    };

#if UNSAFE

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase0"/>
    [return: MaybeNull]
    public static implicit operator T0(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T0>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase1"/>
    [return: MaybeNull]
    public static implicit operator T1(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T1>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase2"/>
    [return: MaybeNull]
    public static implicit operator T2(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T2>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase3"/>
    [return: MaybeNull]
    public static implicit operator T3(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T3>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase4"/>
    [return: MaybeNull]
    public static implicit operator T4(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T4>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase5"/>
    [return: MaybeNull]
    public static implicit operator T5(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T5>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase6"/>
    [return: MaybeNull]
    public static implicit operator T6(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T6>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase7"/>
    [return: MaybeNull]
    public static implicit operator T7(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T7>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase8"/>
    [return: MaybeNull]
    public static implicit operator T8(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T8>();

    /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase9"/>
    [return: MaybeNull]
    public static implicit operator T9(Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> union) => union.As<T9>();
#endif

    /// <summary>
    /// Casts the given <typeparamref name="T0"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T0 value) => new Case0(value);

    /// <summary>
    /// Casts the given <typeparamref name="T1"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T1 value) => new Case1(value);

    /// <summary>
    /// Casts the given <typeparamref name="T2"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T2 value) => new Case2(value);

    /// <summary>
    /// Casts the given <typeparamref name="T3"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T3 value) => new Case3(value);

    /// <summary>
    /// Casts the given <typeparamref name="T4"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T4 value) => new Case4(value);

    /// <summary>
    /// Casts the given <typeparamref name="T5"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T5 value) => new Case5(value);

    /// <summary>
    /// Casts the given <typeparamref name="T6"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T6 value) => new Case6(value);

    /// <summary>
    /// Casts the given <typeparamref name="T7"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T7 value) => new Case7(value);

    /// <summary>
    /// Casts the given <typeparamref name="T8"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T8 value) => new Case8(value);

    /// <summary>
    /// Casts the given <typeparamref name="T9"/>-value to the union type.
    /// </summary>
    /// <param name="value">Value</param>
    public static implicit operator Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>(T9 value) => new Case9(value);


    /// <summary>
    /// Union case №0 (Represents type <typeparamref name="T0"/>).
    /// </summary>
    public sealed record Case0
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase0 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T0 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T0"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T0"/>.</param>
        public Case0(T0 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func0(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func0(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case0).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase0"/>
        public static implicit operator T0(Case0 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase0"/>
        public static explicit operator T0(Case0 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T0"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case0(T0 value) => new Case0(value);
    }

    /// <summary>
    /// Union case №1 (Represents type <typeparamref name="T1"/>).
    /// </summary>
    public sealed record Case1
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase1 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T1 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T1"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T1"/>.</param>
        public Case1(T1 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func1(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func1(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case1).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase1"/>
        public static implicit operator T1(Case1 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase1"/>
        public static explicit operator T1(Case1 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T1"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case1(T1 value) => new Case1(value);
    }

    /// <summary>
    /// Union case №2 (Represents type <typeparamref name="T2"/>).
    /// </summary>
    public sealed record Case2
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase2 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T2 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T2"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T2"/>.</param>
        public Case2(T2 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func2(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func2(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case2).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase2"/>
        public static implicit operator T2(Case2 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase2"/>
        public static explicit operator T2(Case2 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T2"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case2(T2 value) => new Case2(value);
    }

    /// <summary>
    /// Union case №3 (Represents type <typeparamref name="T3"/>).
    /// </summary>
    public sealed record Case3
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase3 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T3 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T3"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T3"/>.</param>
        public Case3(T3 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func3(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func3(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case3).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase3"/>
        public static implicit operator T3(Case3 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase3"/>
        public static explicit operator T3(Case3 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T3"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case3(T3 value) => new Case3(value);
    }

    /// <summary>
    /// Union case №4 (Represents type <typeparamref name="T4"/>).
    /// </summary>
    public sealed record Case4
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase4 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T4 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T4"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T4"/>.</param>
        public Case4(T4 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func4(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func4(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case4).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase4"/>
        public static implicit operator T4(Case4 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase4"/>
        public static explicit operator T4(Case4 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T4"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case4(T4 value) => new Case4(value);
    }

    /// <summary>
    /// Union case №5 (Represents type <typeparamref name="T5"/>).
    /// </summary>
    public sealed record Case5
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase5 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T5 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T5"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T5"/>.</param>
        public Case5(T5 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func5(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func5(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case5).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase5"/>
        public static implicit operator T5(Case5 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase5"/>
        public static explicit operator T5(Case5 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T5"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case5(T5 value) => new Case5(value);
    }

    /// <summary>
    /// Union case №6 (Represents type <typeparamref name="T6"/>).
    /// </summary>
    public sealed record Case6
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase6 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T6 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T6"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T6"/>.</param>
        public Case6(T6 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func6(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func6(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case6).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase6"/>
        public static implicit operator T6(Case6 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase6"/>
        public static explicit operator T6(Case6 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T6"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case6(T6 value) => new Case6(value);
    }

    /// <summary>
    /// Union case №7 (Represents type <typeparamref name="T7"/>).
    /// </summary>
    public sealed record Case7
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase7 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T7 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T7"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T7"/>.</param>
        public Case7(T7 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func7(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func7(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case7).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase7"/>
        public static implicit operator T7(Case7 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase7"/>
        public static explicit operator T7(Case7 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T7"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case7(T7 value) => new Case7(value);
    }

    /// <summary>
    /// Union case №8 (Represents type <typeparamref name="T8"/>).
    /// </summary>
    public sealed record Case8
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase8 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T8 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T8"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T8"/>.</param>
        public Case8(T8 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func8(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func8(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case8).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase8"/>
        public static implicit operator T8(Case8 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase8"/>
        public static explicit operator T8(Case8 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T8"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case8(T8 value) => new Case8(value);
    }

    /// <summary>
    /// Union case №9 (Represents type <typeparamref name="T9"/>).
    /// </summary>
    public sealed record Case9
        : Union<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>
    {
#if UNSAFE
        /// <inheritdoc/>
        public override bool IsCase9 => true;

        /// <inheritdoc/>
        public override object? UnsafeItem => Item;
#endif
        /// <summary>
        /// The union's item.
        /// </summary>
        public T9 Item { get; }


        /// <summary>
        /// Creates a new union with 10 possible cases and sets it to a value of the type <typeparamref name="T9"/>.
        /// </summary>
        /// <param name="item">Union value of the type <typeparamref name="T9"/>.</param>
        public Case9(T9 item) : base() => Item = item;

        /// <inheritdoc/>
        public override T Match<T>(Func<T0, T> func0, Func<T1, T> func1, Func<T2, T> func2, Func<T3, T> func3, Func<T4, T> func4, Func<T5, T> func5, Func<T6, T> func6, Func<T7, T> func7, Func<T8, T> func8, Func<T9, T> func9) => func9(Item);

        /// <inheritdoc/>
        public override void Match(Action<T0> func0, Action<T1> func1, Action<T2> func2, Action<T3> func3, Action<T4> func4, Action<T5> func5, Action<T6> func6, Action<T7> func7, Action<T8> func8, Action<T9> func9) => func9(Item);

        /// <inheritdoc/>
        public override string ToString() => Item?.ToString() ?? typeof(Case9).ToString();

#if UNSAFE
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase9"/>
        public static implicit operator T9(Case9 @case) => @case.Item;
#else
        /// <inheritdoc cref="Union{T0, T1, T2, T3, T4, T5, T6, T7, T8, T9}.AsCase9"/>
        public static explicit operator T9(Case9 @case) => @case.Item;
#endif

        /// <summary>
        /// Casts the given <typeparamref name="T9"/>-value to the union type.
        /// </summary>
        /// <param name="value">Value</param>
        public static implicit operator Case9(T9 value) => new Case9(value);
    }
}
